;----------------------------------------------------- 
;Code: adctopulse3.zr16
;Made by: Tiago Ribas e Michel Rodrigues
;This version implements a way to read the ADC and 
;converts the data to pulses that are sent via RF. Data
;is stored in the SRAM than sent all at once. 
;Before sending the data a verification is made using
;the external interuption to check if no other data
;is being transmitted.
;14/11/2017 - tiago.trj@gmail.com
;------------------zr16-------------------------------
			dv	devide_id	=	0b00101010		;Identificacao do dispositivo
			dr	data_pntr	=	r1  			;Reg. de posicao do ponteiro de dados
;----------controle_de_interupcao---------------------
			dv	esperando	=	0				;Status de interrupcao esperando
			dv	interrompeu	=	1  				;Status de interrupcao interrompeu
			dv	hint_ed	=	0b00000011			;Bit hint e shift pra esquerda
			dv	rot_int	=	0x3C0				;Endereco de rotina de interrupcao
			dv	mem_r0	=	0x00				;Endereco de backup de r0
			dv	r_ctrl_int_st	=	0x00		;Reg. controle de interrupcao
			dv	int_adc	=	0b00000100			;Bits de interrupcao do adc
			dv	int_timer	=	0b00001000		;Bits de interrupcao do timer
			dv	hab_int_ext0_bs	=	0b00000101	;Habilita int externa 0 com borda de subida
			dv	des_int_ext0_bs	=	0b00001000	;Deliga int ext.		
			dr	status_int	=	r2 				;Reg. Armazenamento de int
;----------io-----------------------------------------
			dv	r_io_hsd	=	0x09			;Reg. de hab de saidas digitais
			dv	r_io_sd	=	0x0A				;Reg. valor saida digital
			dv	hsd123	=	0b11000001			;Hab. saida digital 0, 1 e 2
			dv	rodando	=	0b10000000			;Sinaliza que esta rodando em sd7
			dv	erro	=	0b01000000      	;Sinaliza erro em sd7 		  
;----------adc----------------------------------------    
			dv	r_adc_ctrl_st_lsb	=	0x04	;
			dv	r_adc_data_msb	=	0x05		;
			dv	soc_ch3_int	=	0b00111111		;
			dv	adc_stop	=	0b00001111		;
			dv	masc_bit_zero	=	0b00000001	;
			dv	masc_bit_01	=	0b00000011 		;
			dr	r_byte_superior	=	r3			;
			dr	r_byte_inferior	=	r4 			;
;----------timer---------------------------------------       
			dv	r_c0	=	0x1C				;
			dv	r_c1	=	0x1D				;
			dv	r_cont_st	=	0x1E   			;
			dv	hab_timer	=	0b10000111		;
			dv	tempo	=	1000				;0,005s
			dv	dc_msb	=	sr8(tempo)			;
			dv	dc_lsb	=	0x00FF & tempo		;
			dv	tempo_espera	=	50000 		;
			dv	dc_msb_espera	=	sr8(tempo_espera)		;
			dv	dc_lsb_espera	=	0x00FF & tempo_espera	;
			dr	contador	=	r5		;
			dv	ciclos_data	=	20    	;
;----------setup---------------------------------------
			mvs	status_int,esperando	; 
			mvs	data_pntr,0x01		;Começa na posição zero da memória 
			mvs contador,0			;Carrega 0 no contador
			mov	r0,hsd123			;
			mov	io	(r_io_hsd),r0	;
			mov	r0,rodando			;
			mov	io	(r_io_sd),r0	;
			mov	r0,dc_lsb
			mov	io	(r_c0),r0 	
			mov	r0,dc_msb
			mov	io	(r_c1),r0
			mov	r0,soc_ch3_int
			mov	io	(r_adc_ctrl_st_lsb),r0
			mov	r0,hint_ed
			mov	r15,r0
;----------espera_adc----------------------------------- 
adc_check:	mov	status_int,status_int
			jz	adc_check
;----------store_data------------------------------------
check_pntr:	mov	r0,0xFE		;Verifica se a memória está cheia
			cmp	r0,data_pntr	;
			jz	pre_espera		;Caso memória cheia espera para enviar dados
			mov	(data_pntr),r_byte_inferior
			inc	data_pntr
			mov	(data_pntr),r_byte_superior
			inc data_pntr
			mvs	status_int,esperando
			mov	r0,hab_timer		;Liga timer
			mov	io	(r_cont_st),r0 	;
loop_data:	mov	status_int,status_int
			jz	loop_data
			inc	contador
			mov r0,ciclos_data
			cmp r0,contador
			mvs	status_int,esperando
			jnz	loop_data
			mov	r0,0					;Desliga timer
			mov	io	(r_cont_st),r0		;
			jmp	adc_check
pre_espera:	mov r0,adc_stop				;Para o adc
			mov (r_adc_ctrl_st_lsb),r0	;
			mvs r0,esperando			;Esperando por interrupcao
			mov status_int,r0			;
			mov	r0,dc_lsb_espera
			mov	(r_c0),r0
			mov	r0,dc_msb_espera
			mov	(r_c1),r0
			mvs r0,hab_timer			;Habilita timer
			mov	(r_cont_st),r0			;
espera:		mov status_int,status_int	;Veririca se interrompeu
			jz	espera				;Caso nao volta a esperar
			mvs r0, esperando
			mov	status_int,r0
			inc contador
			mov r0,ciclos_espera
			cmp	r0,contador
			jz pre_envio
			jmp espera
pre_envio:	mov	r0,0					;Desliga timer
			mov	io	(r_cont_st),r0		;
			mov	r0,hab_int_ext0_bs		;Hab. int. externa 0 com borda de subida
			mov	io	(r_ctrl_int_st),r0	;
ext_check:	mov	status_int,status_int
			jz	ext_check

			


;----------interrupcao----------------------------------- 			
			org	rot_int		;Inicia rotina de interrupcao
			mov	(mem_r0),r0
			mov	io	r0,(r_ctrl_int_st)		;Verifica qual a interrupcao
			cmp r0,int_adc		;Interrupcao no ADC?
			jz	intadc			;Sim, pula para int do adc
			cmp	r0,int_timer
			jz	inttimer 
			mov	r0,erro		;Nao, erro.
			mov	io	(r_io_sd),r0		;Indica em sd7 erro
			jmp $		;Loop de  errro
intadc:		mvs	status_int, interrompeu
			mvs	r_byte_inferior,masc_bit_01
			mov	r0,r_adc_ctrl_st_lsb
			and	r_byte_inferior,r0 
			mov	r0,r_adc_data_msb
			mov	r_byte_superior,r0
			mov	r0,adc_stop
			mov	io	(r_adc_ctrl_st_lsb),r0
			mov	r0,hab_timer
			mov	io	(r_cont_st),r0
			mov	r0,(mem_r0) 
			rets
inttimer:	mvs	status_int,interrompeu
			mov	r0,hab_timer
			mov	io	(r_cont_st),r0
			mov	r0,(mem_r0)
			rets
intext:		mov	r0,des_int_ext0_bs		;Desliga e limpa int ext
			mov	io	(r_ctrl_int_st),r0	;
			mvs	status_int,interrompeu
			rets 




			

